task Shot(pos :XY, dy) {
    set pos = copy(pos) ;; dont change values outside

    spawn { ;; draw shot independently. Keep drawing it if paused or not paused.
        var should-explode = true

        par-or { ;; draw shot as white rectangle until it collides with smth
            await :Collision.Shot {
                set should-explode = it.should-explode
            }
        } with {
            every :Pico.Draw {
                pico.set.color.draw(WHITE)
                pico.output.draw.rect([pos, [1, 7]])
            }
        }
        
        if should-explode {
            every :Pico.Draw { ;; draw shot explosion
                pico.set.image.crop(nil)
                pico.output.draw.image([pos.x - 3, pos.y], match dy {
                    <= 0 => IMG-EXP2
                    else => IMG-EXP3
                })
            }
        }
    }

    loop { ;; shot state depends on pause state
        watching :Pause.On {
            watching :Collision.Shot {
                every :Pico.Frame { ;; keep moving shot until it's out of bounds
                    set pos.y = pos.y + dy
                    until (pos.y <= 10) or (pos.y >= 240)
                }
            }

            await(<EXPLOSION-TIME:s>) ;; collided or out of bounds
            break()
        }

        await(:Pause.Off)
    }
}
