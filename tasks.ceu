^["constants.ceu"]

enum :State { Dead, Up, Down }
data :Invader = [pos:XY, type, state]

val explosions = tasks(5)
val shots = tasks(5)

task Explosion(pos :XY, lifetime, img) {
    par-or {
        await <lifetime:s>
    } with {
        every :Pico.Draw {
            pico.set.image.crop(nil)
            pico.output.draw.image(pos, img)
        }
    }
}

task Shot(pos :XY, dy) {
    par-or {
        every :Pico.Frame {
            set pos.y = pos.y + dy;
            if pos.y <= 10 {
                val exp_pos = [pos.x - 3, pos.y]
                spawn Explosion(exp_pos, 0.3, IMG_EXP2) in explosions
                break()
            }
        }
    } with {
        every :Pico.Draw {
            pico.set.color.draw(WHITE)
            pico.output.draw.rect([pos, [1, 7]])
        }
    }
}


val CANNON_X_START = 16
val CANNON_Y = 216
val CANNON_DX = 4


task Cannon () {
    var x = CANNON_X_START
    var l = 0
    var r = 0
    
    par-or {
        every :Pico.Key.Dn {
            match it.key {
                == :Key-Left  => set l = CANNON_DX
                == :Key-Right => set r = CANNON_DX
            }
        }
    } with {
        loop {
            await <1:s>
            await(:Pico.Key.Dn | it.key == :Key-Q)

            spawn Shot([x + 8, CANNON_Y - 8], -8) in shots
        }
    } with {
        every :Pico.Key.Up {
            match it.key {
                == :Key-Left  => set l = 0
                == :Key-Right => set r = 0
            }
        }
    } with {
        every :Pico.Frame {
            set x = x + (r - l)
        }
    } with {
        every :Pico.Draw {
            pico.set.image.crop([[0, 0], [16, 8]])
            pico.output.draw.image([x, CANNON_Y], IMG_CANNON)
        }
    }
}

task Horde() {
    func i2xy(i) {
        val r = 4 - math.floor(i / 11)
        val c = i % 11
        [26 + (16 * c), 64 + (16 * r)]
    }

    func i2type(i) {
        i % 2
    }

    var invaders = #[]

    ;; draw invaders regardless of horde state
    spawn {
        every :Pico.Draw {
            loop inv:Invader in invaders {
                match inv.state {
                    :State.Up => pico.set.color.draw(WHITE)
                    :State.Dn => pico.set.color.draw(RED)
                    :State.Dead => {}
                }
                pico.output.draw.rect([inv.pos, [12, 8]])
            }
        }
    }

    ;; populating horde
    loop i {
        set invaders[+] = [i2xy(i), i2type(i), :State.Up]
        await <30:ms>
        while #invaders < 55
    }

    ;; moving
    var dx = 2

    loop {
        var dy = 0

        loop inv:Invader in invaders {
            if (inv.pos.x < 12) or (inv.pos.x > 200) {
                set dx = -dx
                set dy = 8
                break()
            }
        }

        loop inv:Invader in invaders {
            await <15:ms>

            set inv.pos = [inv.pos.x + dx, inv.pos.y + dy]
            set inv.state = match inv.state {
                :State.Up => :State.Dn
                :State.Dn => :State.Up
                :State.Dead => :State.Dead
            }
        }
    }
}
