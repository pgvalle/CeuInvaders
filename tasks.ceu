^["constants.ceu"]

enum :InvaderState { Dead, Up, Down }
data :Invader = [pos :XY, type, state]

val explosions = tasks(5)
val shots = tasks(1)

task Explosion(pos :XY, lifetime, img) {
    watching <lifetime:s> {
        every :Pico.Draw {
            pico.set.image.crop(nil)
            pico.output.draw.image(pos, img)
        }
    }
}

task Shot(pos :XY, dy) {
    par-or {
        every :Pico.Frame {
            set pos.y = pos.y + dy;
            if pos.y <= 10 {
                break()
            }
        }
    } with {
        every :Pico.Draw {
            pico.set.color.draw(WHITE)
            pico.output.draw.rect([pos, [1, 7]])
        }
    }
    spawn Explosion([pos.x - 3, pos.y], 0.3, IMG_EXP2) in explosions
}


val CANNON_X_START = 16
val CANNON_Y = 216
val CANNON_DX = 4


task Cannon () {
    var x = CANNON_X_START
    var l = 0
    var r = 0
    
    par {
        every :Pico.Key.Dn {
            match it.key {
                :Key-Left  => set l = CANNON_DX
                :Key-Right => set r = CANNON_DX
            }
        }
    } with {
        every (:Pico.Key.Dn | it.key == :Key-Q) {
            spawn Shot([x + 8, CANNON_Y - 8], -8) in shots
        }
    } with {
        every :Pico.Key.Up {
            match it.key {
                :Key-Left  => set l = 0
                :Key-Right => set r = 0
            }
        }
    } with {
        every :Pico.Frame {
            set x = x + (r - l)
        }
    } with {
        every :Pico.Draw {
            pico.set.image.crop([[0, 0], [16, 8]])
            pico.output.draw.image([x, CANNON_Y], IMG_CANNON)
        }
    }
}

task Horde() {
    var invaders = #[]

    ;; draw invaders regardless of horde state
    spawn {
        every :Pico.Draw {
            loop inv :Invader in invaders {
                val [crop_size, img] = match inv.type {
                    0 => [[8, 8], IMG_INV1]
                    1 => [[11, 8], IMG_INV2]
                    2 => [[12, 8], IMG_INV3]
                }

                val crop_x = match inv.state {
                    :InvaderState.Up => 0
                    :InvaderState.Dn => crop_size[0]
                }

                if (crop_x) {
                    pico.set.image.crop([[crop_x, 0], crop_size])
                    pico.output.draw.image(inv.pos, img)
                }
            }
        }
    }

    func new_inv(i) {
        val row = 4 - math.floor(i / 11)
        val col = i % 11

        val pos = [26 + (16 * col), 64 + (16 * row)]
        val type = match row {
            0 => 0
            1 => 0
            2 => 1
            3 => 1
            4 => 2
        }

        [pos, type, :InvaderState.Up]
    }

    ;; populating horde
    loop i in {0 => 55{ {
        set invaders[+] = new_inv(i)
        await(:Pico.Frame)
    }

    var dx = 2

    ;; moving
    loop {
        var dy = 0

        loop inv :Invader in invaders {
            if (inv.pos.x < 12) or (inv.pos.x > 200) {
                set dx = -dx
                set dy = 8
                break()
            }
        }

        loop inv :Invader in invaders {
            await(:Pico.Frame)

            set inv.pos = [inv.pos.x + dx, inv.pos.y + dy]
            set inv.state = match inv.state {
                ;; animate invaders
                :InvaderState.Up => :InvaderState.Dn
                :InvaderState.Dn => :InvaderState.Up
                ;; dead invaders remain dead
                :InvaderState.Dead => :InvaderState.Dead
            }
        }
    }
}
